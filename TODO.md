## 首先，这玩意是什么
1. 原身是为满足长持续时间大量测试用例的管理工具
2. 提供了一套不一定好用的标准化方案
3. 提供了标准化的结果记录方案
4. 提供了一套定时自动运行系统，自定义不方便
5. 不直接使用pytest也是为了适应时间等多样需要记录的结果以及多样结果记录方式需要
## 我要改成什么
1. 泛用的测试用例管理工具，必须有高兼容性，整体结构尽量简洁
2. 交互，还是交互，提供合适的交互能力
3. 和pytest兼容，保证用例控制高效（重点）
4. 假设每个用例都需要一段运行时间，从而兼容现有逻辑
5. 这玩意的独特之处，一是在于结果记录方式自定义和标准化，二是做好大批量用例调用管理功能(虽然实际上一个项目管理工具配合简单脚本也能实现)，三是提供用例简易化的思路，但这和项目本身是没什么关系了就
6. 实际上确实，pytest很适合小规模单元测试，但大规模测试不太够用，所以这玩意就有了发挥空间
## 要怎么改
1. 现有项目太庞大了，以完善的部分不要碰，在其基础上修改就好
2. pytest适配基本有眉目了，只要写个钩子就行，然后把运行包装一下，把运行函数包装成直接调用对应pytest用例的函数，完成。整体相当于一个二级封装，所以机制上属于对用例的调用处理工具(自动化工具)
3. 原有的timer适配了一条仅在特定时间内运行的机制，主要目的是让超长的用例集分阶段在多天分别完成。机制上启动timer后只会在允许的时间挂起用例，时间到了后不挂起新用例，直到下一个可行时间，最终到所有用例跑完。很有意思的测略，但没用，考虑废弃，timer也要大改
4. 也因为3，workmodule中与时间相关的设计暂时废弃，重写。新的workmudule将只保留基础功能，也即是运行，记录
5. 同样的,workmodule的记录方式也需要额外考虑，好在recorder的设计已经很完善不用改了
6. 大致思路是，大体流程不变，启动需要接受unitmaster，然后直接拉起unitmaster.run就行，看情况考虑要不要修改unitmaster吧。
7. 另外，原本特化的那个msger也就不需要了，那玩意是适配那个用不到的机器人的
8. 因为原本是为了性能设计的，所以并没有区分用例通过与否，只有成功运行和运行失败。作为一个管理工具这个逻辑倒是没问题，全部交给处理工具去搞吧
9. 然后是timer系统。实际上timer本身暂时不需要实现，先把plan类设计完成吧
    - 首先，plan本身是用yaml的格式写在plan文件夹内的，每个文件代表若干个plan(允许一个文件多个plan，从设计上保证)，一次性读取存入
    - 其次，plan包括如下内容: id(名称，唯一)，cases(用例集，一组测试用例id)，recorders（记录方式，需要额外实现recorders实例放到合适的路径便于记载）。starttime(开始时间，默认为空即立刻开始。在实现timer后该参数才有用)
    - 暂时就这些吧，回头再补充，反正原则上保证没有的参数默认是空也能正常运行就可以
10. 原项目的难点一是特殊场景的执行和记录本身的复杂，二是为了适配复杂的定时要求，timer搞的挺复杂，wordker更是难受。仔细想想当时的需要其实就是做个任务截断和继续。给unitmaster稍作修改记录下运行状态，再注入个能够截断的函数就完成了，不过没需要的话暂时不搞了
11. 笑死了，原本的config一点用都没了，拿过来玩别的吧
## TODO
1. pytestunit实现 √
2. 重写workmodel,这玩意原本是为工具特化的，需要重写来实现通用化。这玩意原本的设计也是读取外部保存的用例文件，思路和后面相近，但是肯定是要改一改的√
3. 同时添加plan.yaml，通过参数控制调用√
4. 用于执行plan的方式√
5. 完成一个简单的tui，适配2，可以交互式操作单个用例，也可以可视化查看plan并启动√
6. 注意需要一个扫描文件的功能，批量读取已编写用例，方便直接根据id分类调用√
7. 修改了成功与否的判定位置，现在所有recorder都需要额外判断报错用例的问题。不过其实挺好说的，其他recorder只要自动跳过错误用例√
8. 后续额外添加错误处理的recorder。
9. 现在改了配置方案后，config好像没有意义了，考虑替换掉√
10. 同上，msgrecorder似乎集成了mdrecorder和企业微信消息的功能，现在的体系下没必要。修改掉其对config的依赖，仅仅做企业微信的recorder即可
11. 在一次执行多unit或者执行plan的情况下，现有逻辑只能做到针对每个unit分别执行和记录，缺乏统一的执行结果反馈。这部分需要修改unitmaster的逻辑，是的能在unitmaster层面实现ui一次运行整体结果的反馈
    - 特别的，现有的逻辑是基于支持每个unit使用不同测试环境和结果记录格式的，因此recorder以用例级别执行是必要到底。前面所说的整体运行结果反馈核心目的是为了给执行人员一个清晰的执行结果记录方式，而不影响测试结果。因此只要简单记录执行了哪些用例/计划，完成了哪些，报错了哪些就足够了。这里有一个取巧的方式是让unitmaster添加reults元素和id属性，然后直接调用recorder来记录unitmaster的结果即可，根据实际情况可能需要考虑添加specifier。
    - 上面的思路实现上很简单，设计上的问题在于，对于unitmaster的recorder的配置应当放在什么位置。无论是指令还是yaml添加这玩意都会增加复杂度。等这个问题想清楚再解决吧(正常的控制台输出，文本输出，以及特殊需要的消息输出和数据库输出。在已经考虑移除config的前提下还挺头疼的)
